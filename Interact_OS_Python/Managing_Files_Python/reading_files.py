
"""
The Open-Use-Close pattern is a typical way of working with files in most programming languages
"""

"""
When we open a file, the operating system the operating system checks that we have permissions to access that file and 
then gives our code a file descriptor. This is a token generated by the OS that allows programs to do more 
operations with the file.

In Python, this file descriptor is stored as an attribute of the files object. 
The file object gives us a bunch of methods that we can use to operate with the file. 
Now, with this file object, we can read the contents of the file and print them to the screen.
"""

# open file
file = open("spyder.txt")       # we are creating a new file object and assigning it the the variable called file

# use file
print(file.readline())      # the readline() method lets us read a single line of a file
print(file.readline())

print(file.read())

# close
file.close()


"""
    The readline() method reads a single line from the current position, the read() method reads from 
    the current position until the end of the file.
    
    - Each time we call the readline method, the file object updates the current position in the file. 
    So it keeps moving forward. 
    - We can also call the read method, which reads from the current position until the end of 
    the file instead of just one line.


    It's a good idea to close files after you've opened them for a few reasons. 
    - First, when a file is opening your script, your file system usually lock it down and so no other programs or 
    scripts can use it until you're finished. 
    - Second, there's a limited number of file descriptors that you can create 
    before your file system runs out of them. 
    Although this number might be high, it's possible to open a lot of files and deplete your file system resources. 
"""


# Alternatively

with open("spyder.txt") as f:
    print(f.readline())
    print(f.readlines()) # a list containing all lines from the current position.
# When we use a with-block, python will automatically close the file

# print(f.readline())     # Error: closed file.



# iterating through files
print("----------------------------iterating through files -----------------------------------")
with open("spyder.txt") as file:
    for line in file:
        print(line.upper())

# to get rid of the empty lines,
with open("spyder.txt") as file:
    for line in file:
        print(line.strip().upper())

f = open("spyder.txt")
lines = f.readlines()
print(lines)


print("-----------------------------------------Writing Files ----------------------------------")
with open("new.txt", 'w') as text_file:
    text_file.write("hello world, i am a python programmer")

"""
    File objects can be opened in several different modes. A mode is similar to a file permission. 
    It governs what you can do with the file you've just opened. By default, the open function uses the r mode, 
    which stands for read only. You get an error if you try to write to a file opened in read only mode. 
    Since read only is the default, we don't have to pass the R as a second argument when we just want to read the file. 
    Writing however is a whole different story. 
    The w character tells the open function that we want to open the file for writing only. 
    If the file doesn't exist then Python will create it. And if it does, its content will be overwritten.
    
    
    'r'     - read only mode
    'w'     - write only mode
    'a'     - append
    'r+'    - read-write mode        
"""




